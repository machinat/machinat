---
title: Service and State
---

> Despite replying messages, a chatbot need many other services to provide features.
> In this lesson, you will learn how to use DI (dependencies injection) system
> to access chat state and other services.
>
> _Time to accomplish: 15 minutes_

## Use Services

Calling users by their name is a common feature to improve chat experience.
Let's implement it by editing `handleChat` like this:

```tsx {8,11} title="src/handlers/handleChat.tsx"
//...
const handleChat = makeContainer({
  deps: [useIntent, useUserProfile],
})(
  (getIntent, getUserProfile) =>
    async (ctx: ChatEventContext & { event: { category: 'message'| 'postback' } }) => {
      //...
      const profile = await getUserProfile(event.user);
      return reply(
        <WithMenu todoCount={3}>
          <p>Hello{profile ? `, ${profile.name}` : ''}! I'm a Todo Bot ðŸ¤–</p>
        </WithMenu>
      );
    }
);
//...
```

Now the bot can say hello with the user's name:

<img width={400} src={require("./assets/hello-with-name.png").default} />

### Service Container

The `handleChat` handler is a **service container**.
A container can delare the services it requires,
and the system will inject the required dependencies at runtime.

`handleChat` is declared by `makeContainer({ deps: [useIntent, useUserProfile] })(...)`.
It requires `useIntent` and `useUserProfile` services, which can then be used like:

```ts
(getIntent, getUserProfile) => async (context) => {/* ... */}
```

The container function takes the required services and return the handler function.
The services then can be used in the handler like:

```ts
  const profile = await getUserProfile(event.user);
```

### Service Provider

Let's go deeper to see what happen in the `useUserProfile` service.
Check the `src/services/useUserProfile.ts` file, you should codes like:

```ts {2-4,10,16-18} title="src/services/useUserProfile.ts"
import {
  makeFactoryProvider,
  BasicProfiler,
  StateController,
  MachinatUser,
  MachinatProfile,
} from '@machinat/core';
//...
const useUserProfile =
  (profiler: BasicProfiler, stateController: StateController) =>
  async (user: MachinatUser) => {
    //...
    return profile;
  };

export default makeFactoryProvider({
  deps: [BasicProfiler, StateController],
})(useUserProfile);
```

The `useUserProfile` is a service provider. It requires its `deps` just like a container.
The difference is that a provider can be required as `deps`, so we can use it to get profile.

`useUserProfile` use two built-in services: `BasicProfiler` and `StateController`.

### Get User Profile

`BasicProfiler` can fetch users' profile no matter which platform they come from.

```ts {6} title="src/services/useUserProfile.ts"
//...
const useUserProfile =
  (profiler: BasicProfiler, stateController: StateController) =>
  async (user: MachinatUser) => {
    //...
    const profile = await profiler.getUserProfile(user);
    if (profile) {
      await userState.set<ProfileCache>('profile_cache', { profile });
    }
    return profile;
  };
//...
```

### Access User State

`StateController` can save/load state data of an user or a channel.

```ts {9-10,17} title="src/services/useUserProfile.ts"
//...
type ProfileCache = {
  profile: MachinatProfile;
};

const useUserProfile =
  (profiler: stateController.userState(uBasicProfiler, stateController: StateController) =>
  async (user: MachinatUser) => {
    const userState = stateController.userState(user);
    const cached = await userState.get<ProfileCache>('profile_cache');
    if (cached) {
      return cached.profile;
    }

    const profile = await profiler.getUserProfile(user);
    if (profile) {
      await userState.set<ProfileCache>('profile_cache', { profile });
    }
    return profile;
  };
//...
```

Here we check if the user's profile is saved under `'profile_cache'` key.
If it is, the cached profile is returned.
Otherwise, the profile is fetched from the platform and being cached.

### State Storage

The state data is stored at `.state_data.json` file while in development.
Ckeck it and you should see the saved profile like:

```json {5-14} title=".state_data.json"
{
  "channelStates": {},
  "userStates": {
    "messenger.12345.67890": {
      "profile_cache": {
        "$type": "MessengerUserProfile",
        "$value": {
          "id": "67890",
          "name": "John Doe",
          "first_name": "John",
          "last_name": "Doe",
          "profile_pic": "https://..."
        }
      }
    }
  },
  "globalStates": {}
}
```

## Providing Services

Let's create a new service to handle the CRUD of todos.

### Create a Service

First add the type of todos state:

```ts title="src/types.ts"
//...
export type TodoState = {
  currentId: number;
  todos: Todo[];
  finishedTodos: Todo[];
};
```

To save time from repeating similar steps, please download the `TodoController.ts` file
with this command:

```bash
curl -o ./src/services/TodoController.ts https://raw.githubusercontent.com/machinat/todo-example/main/src/services/TodoController.ts
```

In the file we create a `TodoController` service to manage todos.
Check `src/services/TodoController.ts`, it's declared like this:

```ts title="src/services/TodoController.ts"
//...
export class TodoController {
  stateController: StateController;

  constructor(stateController: StateController) {
    this.stateController = stateController;
  }
  //...
}

export default makeClassProvider({
  deps: [StateController],
})(TodoController);
```

The `makeClassProvider` works just like `makeFactoryProvider`,
except that the provider is a class.
It also requires `StateController` to save/load todos data.

### Channel State

In the `TodoController` we store the todos data in the `channelState`.
It works the same as `userState`, but it saves the data of a chatroom instead.

```ts {6} title="src/services/TodoController.ts"
//...
async getTodos(
  channel: MachinatChannel
): Promise<{ todo: null; data: TodoState }> {
  const data = await this.stateController
    .channelState(channel)
    .get<TodoState>('todo_data');

  return {
    todo: null,
    data: data || { currentId: 0, todos: [], finishedTodos: [] },
  };
}
//...
```

### Register Services

A new service must be registered in the app before using it.
Register the `TodoController` in `src/app.ts` like:

```ts {1,7-8} title="src/app.ts"
import TodoController from './services/TodoController';
//...
const createApp = (options?: CreateAppOptions) => {
  return Machinat.createApp({
    modules: [/* ... */],
    platforms: [/* ... */],
    services: [
      TodoController,
      // ...
    ],
  });
};
```

### Use `TodoController`

Now `TodoController` can be used like other services.
We can use it to easily complete the CRUD features.
Edit `handleChat` like this:

```tsx {1,4,6,12-13,15-29,36,38,46,48} title="src/handlers/handleChat.tsx"
import TodoController from '../services/TodoController';
// ...
const handleChat = makeContainer({
  deps: [useIntent, useUserProfile, TodoController],
})(
  (getIntent, getUserProfile, todoController) =>
  async (ctx: ChatEventContext & { event: { category: 'message' | 'postback' } }) => {
      const { event, reply } = ctx;
      const intent = await getIntent(event);

      if (intent.type === 'list') {
        const { data } = await todoController.getTodos(event.channel);
        return reply(<TodoList todos={data.todos} />);
      }
      if (intent.type === 'finish') {
        const { todo, data } = await todoController.finishTodo(
          event.channel,
          intent.payload.id
        );
        return reply(
          <WithMenu todoCount={data.todos.length}>
            {todo ? (
              <p>Todo "<b>{todo.name}</b>" is done!</p>
            ) : (
              <p>This todo is closed.</p>
            )}
          </WithMenu>
        );
      }

      if (event.type === 'text') {
        const matchingAddTodo = event.text.match(/add(\s+todo)?(.*)/i);
        if (matchingAddTodo) {
          const todoName = matchingAddTodo[2].trim();

          const { data } = await todoController.addTodo(event.channel, todoName);
          return reply(
            <WithMenu todoCount={data.todos.length}>
              <p>Todo "<b>{todoName}</b>" is added!</p>
            </WithMenu>
          );
        }
      }

      const profile = await profiler.getUserProfile(event.user);
      const { data } = await todoController.getTodos(event.channel);
      await reply(
        <WithMenu todoCount={data.todos.length}>
          <p>Hello{profile ? `, ${profile.name}` : ''}! I'm a Todo Bot ðŸ¤–</p>
        </WithMenu>
      );
    }
);
//...
```


Now try adding a todo with `add todo <name>` command, and check the `.state_data.json`
file. You should see the stored todo data like:

```json {5-13} title=".state_data.json"
{
  "userStates": {...},
  "channelStates": {
    "messenger.12345.psid.67890": {
      "todo_data": {
        "currentId": 1,
        "todos": [
          {
            "id": 1,
            "name": "Master State Service"
          }
        ],
        "finishedTodos": []
      }
    }
  },
  "globalStates": {}
}
```

Then press `Done âœ“` button in the todos list, the bot should reply like:

<img width={400} src={require("./assets/finish-todo.png").default} />

Check `.state_data.json`, the todo should be moved to the
`"finishedTodos"` section:

```json title=".state_data.json"
    "finishedTodos": [
      {
        "id": 1,
        "name": "Master State Service"
      }
    ]
```

---

Now our bot can provide real feature with real data in the state.
Next, we'll make the bot to understand what we say.
